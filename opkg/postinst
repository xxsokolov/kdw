#!/bin/sh

# KDW Bot Post-Installation Script (FINAL, logmsg-aware)

# --- Functions ---
echo_step() {
  echo "-> $1"
}
echo_success() {
  echo "[OK] $1"
}
echo_error() {
  echo "[ERROR] $1"
  exit 1
}

# --- 1. Argument Parsing ---
BOT_TOKEN=""
USER_ID=""

while [ "$1" != "" ]; do
    case $1 in
        --token)
            shift
            BOT_TOKEN=$1
            ;;
        --user-id)
            shift
            USER_ID=$1
            ;;
    esac
    shift
done

# --- 2. Interactive Configuration ---
echo_step "Настройка конфигурации..."
if [ -z "$BOT_TOKEN" ]; then
  echo "Пожалуйста, введите данные для настройки бота:"
  printf "1. Токен вашего Telegram бота: "
  read BOT_TOKEN
  if [ -z "$BOT_TOKEN" ]; then echo_error "Токен не может быть пустым."; fi

  printf "2. Ваш Telegram User ID: "
  read USER_ID
  if [ -z "$USER_ID" ]; then echo_error "User ID не может быть пустым."; fi
else
  echo "Используются параметры, переданные при запуске."
fi

# --- 3. Validate Token & Dependencies ---
echo_step "Проверка токена и зависимостей..."
if ! command -v python3 > /dev/null; then echo_error "Python3 не найден. Убедитесь, что пакет 'python3' установлен."; fi
PYTHON_EXEC=$(command -v python3)

API_URL="https://api.telegram.org/bot$BOT_TOKEN/getMe"
RESPONSE=$(curl -s "$API_URL")
OK_STATUS=$(echo $RESPONSE | jq -r '.ok')

if [ "$OK_STATUS" != "true" ]; then
  echo_error "Неверный токен. Telegram API вернул ошибку:"
  echo "$RESPONSE"
  exit 1
fi
BOT_USERNAME=$(echo $RESPONSE | jq -r '.result.username')
echo_success "Токен верный. Бот: @$BOT_USERNAME"

# --- 4. Create Config File ---
echo_step "Создание конфигурационного файла kdw.cfg..."
PROJECT_DIR="/opt/etc/kdw"
CONFIG_FILE="${PROJECT_DIR}/kdw.cfg"

cat > $CONFIG_FILE << EOF
[telegram]
token = $BOT_TOKEN
access_ids = [$USER_ID]
[installer]
script_path = ${PROJECT_DIR}/scripts/install.sh
network_interface = br0
[keenetic]
host = 127.0.0.1
port = 80
user = admin
password =
[shadowsocks]
path = /opt/etc/shadowsocks
file_mask = *.json
EOF
echo_success "Конфигурационный файл создан."

# --- 5. Create Service ---
echo_step "Создание службы автозапуска S99kdwbot..."
SERVICE_DIR="/opt/etc/init.d"
SERVICE_FILE="${SERVICE_DIR}/S99kdwbot"

mkdir -p "$SERVICE_DIR"

if [ -f "$SERVICE_FILE" ]; then
    sh "$SERVICE_FILE" stop
fi

cat > $SERVICE_FILE << EOF
#!/bin/sh
# KDW Bot Service (logmsg-aware)
BOT_PATH="${PROJECT_DIR}/kdw_bot.py"
PYTHON_EXEC="$PYTHON_EXEC"
PID_FILE="/var/run/kdw_bot.pid"

start() {
    if [ -f "\$PID_FILE" ] && ps | grep -q "^\s*\$(cat \$PID_FILE)\s"; then
        echo "KDW Bot is already running."
        return
    fi
    echo "Starting KDW Bot..."
    # Запускаем бот в фоне, он сам будет писать в системный журнал
    \$PYTHON_EXEC \$BOT_PATH &
    echo \$! > \$PID_FILE
}

stop() {
    if [ ! -f "\$PID_FILE" ]; then
        echo "KDW Bot is not running (PID file not found)."
        return
    fi

    PID=\$(cat \$PID_FILE)
    if ! ps | grep -q "^\s*\$PID\s"; then
        echo "KDW Bot is not running (stale PID file found)."
        rm -f \$PID_FILE
        return
    fi

    echo "Stopping KDW Bot (PID: \$PID)..."
    kill \$PID
    rm -f \$PID_FILE
}

case "\$1" in
    start|restart)
        stop; sleep 2; start
        ;;
    stop)
        stop
        ;;
    *)
        echo "Usage: \$0 {start|stop|restart}"
        exit 1
esac
EOF
chmod +x $SERVICE_FILE
echo_success "Служба создана."

# --- 6. Final ---
echo_step "Запуск бота..."
$SERVICE_FILE start
sleep 2 # Небольшая пауза для стабилизации

# --- 7. Проверка успешного запуска ---
echo_step "Проверка статуса запущенного бота..."
if [ -f /var/run/kdw_bot.pid ] && ps | grep -q "^\s*$(cat /var/run/kdw_bot.pid)\s"; then
    echo_success "Процесс бота успешно запущен."
    echo ""
    echo "--- Что дальше? ---"
    echo "1. Откройте Telegram и найдите вашего бота: @${BOT_USERNAME}"
    echo "2. Отправьте ему команду /start, чтобы появилось главное меню."
    echo "3. Следите за логами в системном журнале Keenetic."
    echo ""
else
    echo_error "Не удалось запустить процесс бота. Проверьте системный журнал Keenetic для получения подробной информации."
    exit 1
fi

exit 0
